# Python学习入门基础 — 第五章 函数基础、函数进阶



# 一、函数基础

- 函数的快速体验
- 函数的基本使用
- 函数的参数
- 函数的返回值
- 函数的嵌套调用
- 在模块中定义函数

## 01. 函数的快速体验

### 1.1 快速体验

- 所谓**函数**，就是把 **具有独立功能的代码块** 组织为一个小模块，在需要的时候 **调用**
- 函数的使用包含两个步骤： 
  1. 定义函数 —— **封装** 独立的功能
  2. 调用函数 —— 享受 **封装** 的成果
- **函数的作用**，在开发程序时，使用函数可以提高编写的效率以及代码的 **重用**

**演练步骤**

1. 新建 `04_函数` 项目
2. 复制之前完成的 **乘法表** 文件
3. 修改文件，增加函数定义 `multiple_table():`
4. 新建另外一个文件，使用 `import` 导入并且调用函数

## 02. 函数基本使用

### 2.1 函数的定义

定义函数的格式如下：

```javascript
def 函数名():

    函数封装的代码
    ……
```

复制

1. `def` 是英文 `define` 的缩写
2. **函数名称** 应该能够表达 **函数封装代码** 的功能，方便后续的调用
3. 函数名称的命名应该符合标识符的命名规则
   - 可以由 **字母**、**下划线** 和 **数字** 组成
   - **不能以数字开头**
   - **不能与关键字重名**

### 2.2 函数调用

调用函数很简单的，通过 `函数名()` 即可完成对函数的调用

### 2.3 第一个函数演练

**需求**

- 1. 编写一个打招呼 `say_hello` 的函数，封装三行打招呼的代码
- 1. 在函数下方调用打招呼的代码

```javascript
name = "小明"


# 解释器知道这里定义了一个函数
def say_hello():
    print("hello 1")
    print("hello 2")
    print("hello 3")

print(name)
# 只有在调用函数时，之前定义的函数才会被执行
# 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码
say_hello()

print(name)
```

复制

>  用 **单步执行 F8 和 F7** 观察以下代码的执行过程 

- 定义好函数之后，只表示这个函数封装了一段代码而已
- 如果不主动调用函数，函数是不会主动执行的

#### 思考

-  能否将函数调用放在函数定义的上方？ 
  - 不能！
  - 因为在 **使用函数名** 调用函数之前，必须要保证 `Python` 已经知道函数的存在
  - 否则控制台会提示 `NameError: name 'say_hello' is not defined` (**名称错误：say_hello 这个名字没有被定义**)

### 2.4 PyCharm 的调试工具

- **F8 Step Over** 可以单步执行代码，会把函数调用看作是一行代码直接执行
- **F7 Step Into** 可以单步执行代码，如果是函数，会进入函数内部

### 2.5 函数的文档注释

- 在开发中，如果希望给函数添加注释，应该在 **定义函数** 的下方，使用 **连续的三对引号**
- 在 **连续的三对引号** 之间编写对函数的说明文字
- 在 **函数调用** 位置，使用快捷键 `CTRL + Q` 可以查看函数的说明信息

>  注意：因为 **函数体相对比较独立**，**函数定义的上方**，应该和其他代码（包括注释）保留 **两个空行** 

## 03. 函数的参数

**演练需求**

1. 开发一个 `sum_2_num` 的函数
2. 函数能够实现 **两个数字的求和** 功能

演练代码如下：

```javascript
def sum_2_num():

    num1 = 10
    num2 = 20
    result = num1 + num2

    print("%d + %d = %d" % (num1, num2, result))

sum_2_num()
```

复制

**思考一下存在什么问题**

>  函数只能处理 **固定数值** 的相加 

**如何解决？**

- 如果能够把需要计算的数字，在调用函数时，传递到函数内部就好了！

### 3.1 函数参数的使用

- 在函数名的后面的小括号内部填写 **参数**
- 多个参数之间使用 `,` 分隔

```javascript
def sum_2_num(num1, num2):

    result = num1 + num2
    
    print("%d + %d = %d" % (num1, num2, result))

sum_2_num(50, 20)
```

复制

### 3.2 参数的作用

- **函数**，把 **具有独立功能的代码块** 组织为一个小模块，在需要的时候 **调用**
- 函数的参数，增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据
  1. 在函数 **内部**，把参数当做 **变量** 使用，进行需要的数据处理
  2. 函数调用时，按照函数定义的**参数顺序**，把 **希望在函数内部处理的数据**，**通过参数** 传递

### 3.3 形参和实参

- **形参**：**定义** 函数时，小括号中的参数，是用来接收参数用的，在函数内部 **作为变量使用**
- **实参**：**调用** 函数时，小括号中的参数，是用来把数据传递到 **函数内部** 用的

## 04. 函数的返回值

- 在程序开发中，有时候，会希望 **一个函数执行结束后，告诉调用者一个结果**，以便调用者针对具体的结果做后续的处理
- **返回值** 是函数 **完成工作**后，**最后** 给调用者的 **一个结果**
- 在函数中使用 `return` 关键字可以返回结果
- 调用函数一方，可以 **使用变量** 来 **接收** 函数的返回结果

>  注意：`return` 表示返回，后续的代码都不会被执行 

```javascript
def sum_2_num(num1, num2):
    """对两个数字的求和"""

    return num1 + num2

# 调用函数，并使用 result 变量接收计算结果
result = sum_2_num(10, 20)

print("计算结果是 %d" % result)
```

复制

## 05. 函数的嵌套调用

- 一个函数里面 **又调用** 了 **另外一个函数**，这就是 **函数嵌套调用**

- 如果函数 

  ```
  test2
  ```

   中，调用了另外一个函数 

  ```
  test1
  ```

  - 那么执行到调用 `test1` 函数时，会先把函数 `test1` 中的任务都执行完
  - 才会回到 `test2` 中调用函数 `test1` 的位置，继续执行后续的代码

```javascript
def test1():

    print("*" * 50)
    print("test 1")
    print("*" * 50)


def test2():

    print("-" * 50)
    print("test 2")
    
    test1()
    
    print("-" * 50)

test2()
```

复制

### 函数嵌套的演练 —— 打印分隔线

>  体会一下工作中 **需求是多变** 的 

**需求 1**

- 定义一个 `print_line` 函数能够打印 `*` 组成的 **一条分隔线**

```javascript
def print_line(char):

    print("*" * 50)
```

复制

**需求 2**

- 定义一个函数能够打印 **由任意字符组成** 的分隔线

```javascript
def print_line(char):

    print(char * 50)
```

复制

**需求 3**

- 定义一个函数能够打印 **任意重复次数** 的分隔线

```javascript
def print_line(char, times):

    print(char * times)
```

复制

**需求 4**

- 定义一个函数能够打印 **5 行** 的分隔线，分隔线要求符合**需求 3**

>  提示：工作中针对需求的变化，应该冷静思考，**不要轻易修改之前已经完成的，能够正常执行的函数**！ 

```javascript
def print_line(char, times):

    print(char * times)


def print_lines(char, times):

    row = 0
    
    while row < 5:
        print_line(char, times)

        row += 1
```

复制

## 06. 使用模块中的函数

>  **模块是 Python 程序架构的一个核心概念** 

- **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要 **导入 import** 这个模块
- 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
- 在模块中定义的 **全局变量** 、 **函数** 都是模块能够提供给外界直接使用的工具

### 6.1 调用模块函数步骤

- 可以 **在一个 Python 文件** 中 **定义 变量 或者 函数**
- 然后在 **另外一个文件中** 使用 `import` 导入这个模块
- 导入之后，就可以使用 `模块名.变量` / `模块名.函数` 的方式，使用这个模块中定义的变量或者函数

>  **模块**可以让 **曾经编写过的代码** 方便的被 **复用**！ 

### 6.2 模块名也是一个标识符

- 标示符可以由 **字母**、**下划线** 和 **数字** 组成
- **不能以数字开头**
- **不能与关键字重名**

>  注意：如果在给 Python 文件起名时，**以数字开头** 是无法在 `PyCharm` 中通过导入这个模块的 

### 6.3 Pyc 文件

>  `C` 是 `compiled` **编译过** 的意思 

**操作步骤**

1. 浏览程序目录会发现一个 `__pycache__` 的目录
2. 目录下会有一个 `.pyc`结尾 文件，`cpython-xx.` 表示 `Python` 解释器的版本
3. 这个 `pyc` 文件是由 Python 解释器将 **模块的源码** 转换为 **字节码**

- `Python` 这样保存 **字节码** 是作为一种启动 **速度的优化**

**字节码**

- ```
  Python
  ```

   在解释源程序时是分成两个步骤的 

  1. 首先处理源代码，**编译** 生成一个二进制 **字节码**
  2. 再对 **字节码** 进行处理，才会生成 CPU 能够识别的 **机器码**

-  有了模块的字节码文件之后，下一次运行程序时，如果在 **上次保存字节码之后** 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤 

-  当 `Python` 重编译时，它会自动检查源文件和字节码文件的时间戳 

-  如果你又修改了源代码，下次程序运行时，字节码将自动重新创建 

>  提示：有关模块以及模块的其他导入方式，后续还会逐渐展开！ **模块是 Python 程序架构的一个核心概念** 

# 二、函数进阶

- 函数参数和返回值的作用
- 函数的返回值 进阶
- 函数的参数 进阶
- 递归函数

## 01. 函数参数和返回值的作用

函数根据 **有没有参数** 以及 **有没有返回值**，可以 **相互组合**，一共有 **4 种** 组合形式

1. 无参数，无返回值
2. 无参数，有返回值
3. 有参数，无返回值
4. 有参数，有返回值

>  定义函数时，**是否接收参数，或者是否返回结果**，是根据 **实际的功能需求** 来决定的！ 

1. 如果函数 **内部处理的数据不确定**，就可以将外界的数据以参数传递到函数内部
2. 如果希望一个函数 **执行完成后，向外界汇报执行结果**，就可以增加函数的返回值

### 1.1 无参数，无返回值

此类函数，不接收参数，也没有返回值，应用场景如下：

1. **只是单纯地做一件事情**，例如 **显示菜单**
2. 在函数内部 **针对全局变量进行操作**，例如：**新建名片**，最终结果 **记录在全局变量** 中

- 如果全局变量的数据类型是一个 **可变类型**，在函数内部可以使用 **方法** 修改全局变量的内容 —— **变量的引用不会改变**（可理解为**函数内部变量和全局变量定义的都是指向相同地址值**）
- 在函数内部，**使用赋值语句** 才会 **修改变量的引用**

### 1.2 无参数，有返回值

此类函数，不接收参数，但是有返回值，应用场景如下：

- 采集数据，例如 **温度计**，返回结果就是当前的温度，而不需要传递任何的参数

### 1.3 有参数，无返回值

此类函数，接收参数，没有返回值，应用场景如下：

- 函数内部的代码保持不变，针对 **不同的参数 处理 不同的数据**
- 例如 **名片管理系统** 针对 **找到的名片** 做 **修改**、**删除** 操作

### 1.4 有参数，有返回值

此类函数，接收参数，同时有返回值，应用场景如下：

- 函数内部的代码保持不变，针对 **不同的参数 处理 不同的数据**，并且 **返回期望的处理结果**
- 例如名片管理系统使用字典默认值和提示信息提示用户输入内容 
  - 如果输入，返回输入内容
  - 如果没有输入，返回字典默认值

## 02. 函数的返回值 进阶

- 在程序开发中，有时候，会希望 **一个函数执行结束后，告诉调用者一个结果**，以便调用者针对具体的结果做后续的处理
- **返回值** 是函数 **完成工作**后，**最后** 给调用者的 **一个结果**
- 在函数中使用 `return` 关键字可以返回结果
- 调用函数一方，可以 **使用变量** 来 **接收** 函数的返回结果

>  问题：一个函数执行后能否返回多个结果？ 

### 示例 —— 温度和湿度测量

- 假设要开发一个函数能够同时返回当前的温度和湿度
- **先完成返回温度**的功能如下：

```javascript
def measure():
    """返回当前的温度"""
    
    print("开始测量...")
    temp = 39
    print("测量结束...")
    
    return temp

result = measure()
print(result)
```

复制

- 在利用 **元组** 在返回温度的同时，也能够返回 **湿度**
- 改造如下：

```javascript
def measure():
    """返回当前的温度"""

    print("开始测量...")
    temp = 39
    wetness = 10
    print("测量结束...")

    return (temp, wetness)
```

复制

>  提示：如果一个函数返回的是元组，括号可以省略 

**技巧**

- 在 `Python` 中，可以 **将一个元组** 使用 **赋值语句** 同时赋值给 **多个变量**
- 注意：变量的数量需要和元组中的元素数量保持一致

```javascript
result = temp, wetness = measure()
```

复制

### 面试题 —— 交换两个数字

**题目要求**

1. 有两个整数变量 `a = 6`, `b = 100`
2. 不使用其他变量，**交换两个变量的值**

#### 解法 1 —— 使用其他变量

```javascript
# 解法 1 - 使用临时变量
c = b
b = a
a = c
```

复制

#### 解法 2 —— 不使用临时变量

```javascript
# 解法 2 - 不使用临时变量
a = a + b
b = a - b
a = a - b
```

复制

#### 解法 3 —— Python 专有，利用元组

```javascript
a, b = b, a
```

复制

## 03. 函数的参数 进阶

### 3.1. 不可变和可变的参数

>  问题 1：在函数内部，针对参数使用 **赋值语句**，会不会影响调用函数时传递的 **实参变量**？ —— 不会！ 

- 无论传递的参数是可变还是不可变
  - 只要 **针对参数** 使用 **赋值语句**，会在 **函数内部** 修改 **局部变量的引用**，**不会影响到 外部变量的引用**

```javascript
def demo(num, num_list):

    print("函数内部")

    # 赋值语句
    num = 200
    num_list = [1, 2, 3]

    print(num)
    print(num_list)

    print("函数代码完成")


gl_num = 99
gl_list = [4, 5, 6]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)
```

复制

>  问题 2：如果传递的参数是 **可变类型**，在函数内部，使用 **方法** 修改了数据的内容，**同样会影响到外部的数据** 

```javascript
def mutable(num_list):

    # num_list = [1, 2, 3]
    num_list.extend([1, 2, 3])
    
    print(num_list)

gl_list = [6, 7, 8]
mutable(gl_list)
print(gl_list)
```

复制

#### 面试题 —— `+=`

- 在 `python` 中，列表变量调用 `+=` 本质上是在执行列表变量的 `extend` 方法，不会修改变量的引用

```javascript
def demo(num, num_list):

    print("函数内部代码")

    # num = num + num
    num += num
    # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用
    # 函数执行结束后，外部数据同样会发生变化
    num_list += num_list

    print(num)
    print(num_list)
    print("函数代码完成")


gl_num = 9
gl_list = [1, 2, 3]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)
```

复制

### 3.2 缺省参数

- 定义函数时，可以给 **某个参数** 指定一个**默认值**，具有默认值的参数就叫做 **缺省参数**
- 调用函数时，如果没有传入 **缺省参数** 的值，则在函数内部使用定义函数时指定的 **参数默认值**
- 函数的缺省参数，**将常见的值设置为参数的缺省值**，从而 **简化函数的调用**
- 例如：对列表排序的方法

```javascript
gl_num_list = [6, 3, 9]

# 默认就是升序排序，因为这种应用需求更多
gl_num_list.sort()
print(gl_num_list)

# 只有当需要降序排序时，才需要传递 `reverse` 参数
gl_num_list.sort(reverse=True)
print(gl_num_list)
```

复制

#### 指定函数的缺省参数

- 在参数后使用赋值语句，可以指定参数的缺省值

```javascript
def print_info(name, gender=True):

    gender_text = "男生"
    if not gender:
        gender_text = "女生"

    print("%s 是 %s" % (name, gender_text))
```

复制

**提示**

1. 缺省参数，需要使用 **最常见的值** 作为默认值！
2. 如果一个参数的值 **不能确定**，则不应该设置默认值，具体的数值在调用函数时，由外界传递！

#### 缺省参数的注意事项

##### 1) 缺省参数的定义位置

- **必须保证** **带有默认值的缺省参数** **在参数列表末尾**
- 所以，以下定义是错误的！

```javascript
def print_info(name, gender=True, title):
```

复制

##### 2) 调用带有多个缺省参数的函数

- 在 **调用函数时**，如果有 **多个缺省参数**，**需要指定参数名**，这样解释器才能够知道参数的对应关系！

```javascript
def print_info(name, title="", gender=True):
    """ :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 """

    gender_text = "男生"

    if not gender:
        gender_text = "女生"

    print("%s%s 是 %s" % (title, name, gender_text))


# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！
print_info("小明")
print_info("老王", title="班长")
print_info("小美", gender=False)
```

复制

### 3.3 多值参数

#### 定义支持多值参数的函数

-  有时可能需要 **一个函数** 能够处理的参数 **个数** 是不确定的，这个时候，就可以使用 **多值参数** 

- ```
  python
  ```

   中有两种多值参数： 

  - 参数名前增加 **一个** `*` 可以接收 **元组**
  - 参数名前增加 **两个** `*` 可以接收 **字典**

-  一般在给多值参数命名时，习惯使用以下两个名字 

  - `*args` —— 存放 **元组** 参数，前面有一个 `*`
  - `**kwargs` —— 存放 **字典** 参数，前面有两个 `*`

-  `args` 是 `arguments` 的缩写，有变量的含义 

-  `kw` 是 `keyword` 的缩写，`kwargs` 可以记忆 **键值对参数** 

```javascript
def demo(num, *args, **kwargs):

    print(num)
    print(args)
    print(kwargs)


demo(1, 2, 3, 4, 5, name="小明", age=18, gender=True)
```

复制

>  提示：**多值参数** 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，**有利于我们能够读懂大牛的代码** 

#### 多值参数案例 —— 计算任意多个数字的和

**需求**

1. 定义一个函数 `sum_numbers`，可以接收的 **任意多个整数**
2. 功能要求：将传递的 **所有数字累加** 并且返回累加结果

```javascript
def sum_numbers(*args):

    num = 0
    # 遍历 args 元组顺序求和
    for n in args:
        num += n

    return num

print(sum_numbers(1, 2, 3))
```

复制

#### 元组和字典的拆包

- 在调用带有多值参数的函数时，如果希望： 
  - 将一个 **元组变量**，直接传递给 `args`
  - 将一个 **字典变量**，直接传递给 `kwargs`
- 就可以使用拆包，简化参数的传递，拆包的方式是： 
  - 在 **元组变量前**，增加 **一个** `*`
  - 在 **字典变量前**，增加 **两个** `*`

```javascript
def demo(*args, **kwargs):

    print(args)
    print(kwargs)


# 需要将一个元组变量/字典变量传递给函数对应的参数
gl_nums = (1, 2, 3)
gl_xiaoming = {
   "name": "小明", "age": 18}

# 会把 num_tuple 和 xiaoming 作为元组传递个 args
# demo(gl_nums, gl_xiaoming)
demo(*gl_nums, **gl_xiaoming)
```

复制

## 04. 函数的递归

>  函数调用自身的 **编程技巧** 称为递归 

### 4.1 递归函数的特点

**特点**

- 一个函数内部调用自己
  - 函数内部可以调用其他函数，当然在函数内部也可以调用自己

**代码特点**

1. 函数内部的 **代码** 是相同的，只是针对 **参数** 不同，**处理的结果不同**
2. 当参数满足一个条件时，函数不再执行 
   - **这个非常重要**，通常被称为递归的出口，否则 **会出现死循环**！

示例代码

```javascript
def sum_numbers(num):

    print(num)
    
    # 递归的出口很重要，否则会出现死循环
    if num == 1:
        return

    sum_numbers(num - 1)
    
sum_numbers(3)
```

复制

### 4.2 递归案例 —— 计算数字累加

**需求**

1. 定义一个函数 `sum_numbers`
2. 能够接收一个 `num` 的整数参数
3. 计算 1 + 2 + … num 的结果

```javascript
def sum_numbers(num):

    if num == 1:
        return 1
    
    # 假设 sum_numbers 能够完成 num - 1 的累加
    temp = sum_numbers(num - 1)

    # 函数内部的核心算法就是 两个数字的相加
    return num + temp

print(sum_numbers(2))
```

复制

![img](https://ask.qcloudimg.com/http-save/yehe-1011815/d7a72fe08b412ff8566dabba91eff824.png?imageView2/2/w/1620)

>  提示：递归是一个 **编程技巧**，初次接触递归会感觉有些吃力！在处理 **不确定的循环条件时**，格外的有用，例如：**遍历整个文件目录的结构** 

